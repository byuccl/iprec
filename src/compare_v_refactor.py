# Copyright 2020-2022 IPRec Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0

"""
Helper functions importing/exporting iGraphs and comparing vertices

Note:
This file uses the following syntax:

for i in list1:
    for j in list2:
        if x:
            break
    else:
        do something

Familiarize yourself with the syntax here: https://stackoverflow.com/a/1859099
"""

from boolean import BooleanAlgebra
from igraph import Graph
from itertools import zip_longest
import re


######### TCL Generated JSON to iGraph #########
def import_design(design, flat):
    """
    Main function for importing JSON generated by record_core.tcl into
    an iGraph object.
    """
    g = Graph(directed=True)
    cells = design["CELLS"]
    g.add_vertices(len(list(cells.keys())))

    # Import all cells
    for vertex, (i, (c_name, c_info)) in zip(g.vs, enumerate(cells.items())):
        vertex["id"] = i
        vertex["label"] = c_name.split("/")[-1]
        vertex["name"] = c_name
        vertex["parent"] = c_info["PARENT"]
        vertex["IS_PRIMITIVE"] = True if c_info["IS_PRIMITIVE"] else False

        if c_info["IS_PRIMITIVE"] == 1:
            vertex["color"] = "orange"
            vertex["ref"] = c_info["REF_NAME"]
            vertex["BEL_PROPERTIES"] = c_info["BEL_PROPERTIES"]
        else:
            vertex["color"] = "green"
            orig_ref = c_info["ORIG_REF_NAME"]
            vertex["ref"] = orig_ref if orig_ref else c_info["REF_NAME"]
            vertex["CELL_PROPERTIES"] = c_info["CELL_PROPERTIES"]

        if "CELL_NAME" in c_info:
            vertex["CELL_NAME"] = c_info["CELL_NAME"]

        if vertex["ref"] in ["IBUF", "OBUF"]:
            vertex["color"] = "blue"

    if flat:
        return create_edges_flat(g, design["NETS"])

    return create_edges_hier(g, design["NETS"])


def create_edges_flat(g, nets):
    """
    Creates edges from a flat design JSON recorded by record_core.tcl
    """
    vertex_edges = []
    edge_attr = {
        "name": [],
        "parent": [],
        "in_pin": [],
        "out_pin": [],
        "signal": [],
        "ports": [],
    }

    for net, net_info in nets.items():
        parent = net_info["PARENT"]
        driver = net_info["LEAF.0"]["OUTPUTS"]
        if len(driver) != 1:
            continue
        driver = driver[0]
        driver_pin_name = driver.rsplit("/", 1)
        driver_v = g.vs.select(name=driver_pin_name[0])
        if not len(driver_v):
            continue
        driver_idx = driver_v[0].index
        for pin in net_info["LEAF.0"]["INPUTS"]:
            if pin == driver:
                continue
            pin = pin.rsplit("/", 1)
            pin_idx = g.vs.select(name=pin[0])[0].index
            vertex_edges.append((driver_idx, pin_idx))
            edge_attr["name"].append(net)
            edge_attr["parent"].append(parent)
            edge_attr["in_pin"].append(pin[1])
            edge_attr["out_pin"].append(driver_pin_name[1])
            edge_attr["signal"].append("primitive")

    edge_attr["ports"] = [dict() for i in vertex_edges]
    g.add_edges(vertex_edges, edge_attr)
    return g


def create_edges_hier(g, nets):
    """
    Creates edges from a hierarchal design JSON recorded by record_core.tcl
    """
    vertex_edges = []
    edge_attr = {"name": [], "parent": [], "in_pin": [], "out_pin": [], "signal": []}

    for net, net_info in nets.items():
        parent = net_info["PARENT"]
        driver = net_info["DRIVER"]

        if "VCC/P" in driver:
            driver_type = "CONST1"
        elif "GND/G" in driver:
            driver_type = "CONST0"
        else:
            driver_type = "primitive"

        driver_pin_name = driver.rsplit("/", 1)
        driver_v = g.vs.select(name=driver_pin_name[0])
        if not len(driver_v):
            continue

        driver_bool = "LEAF.0"  # default leaf bool
        for pin_dir in ["INPUTS", "OUTPUTS"]:
            for y in net_info["LEAF.1"][pin_dir]:
                if y == driver:
                    driver_bool = "LEAF.1"

        driver_idx = driver_v[0].index
        for leaf_bool in ["LEAF.0", "LEAF.1"]:
            for pin_dir, pins in net_info[leaf_bool].items():
                for pin in pins:
                    if pin == driver:
                        continue
                    pin = pin.rsplit("/", 1)
                    pin_idx = g.vs.select(name=pin[0])
                    if len(pin_idx) != 1:
                        print(f"PIN INDEX ERROR {pin}")
                        continue
                    pin_idx = pin_idx[0].index
                    if driver_bool == "LEAF.1" and leaf_bool == "LEAF.1":
                        edge_type = driver_type
                    else:
                        edge_type = "port"
                    vertex_edges.append((driver_idx, pin_idx))
                    edge_attr["name"].append(net)
                    edge_attr["parent"].append(parent)
                    edge_attr["in_pin"].append(pin[1])
                    edge_attr["out_pin"].append(driver_pin_name[1])
                    edge_attr["signal"].append(edge_type)

    edge_attr["ports"] = [dict() for i in vertex_edges]
    g.add_edges(vertex_edges, edge_attr)
    return g


######### iGraph to Text File #########
def print_graph(graph_obj, f):
    """Print iGraph in readable-text format to a file"""
    print("GRAPH TOP:", file=f)
    for p in graph_obj.attributes():
        print(f"\t{p}: {graph_obj[p]}", file=f)

    for v in graph_obj.vs:
        print(v.index, file=f)
        for p in v.attributes():
            print(f"\t{p}: {v[p]}", file=f)

    for e in graph_obj.es():
        print(e.index, file=f)
        for p in e.attributes():
            print(f"\t{p}: {e[p]}", file=f)
        print(f"\t{e.source} -> {e.target}", file=f)


######### iGraph Comparison Functions #########
def compare_eqn(eq1, eq2):
    eq1 = BooleanAlgebra().parse(eq1[3:]).simplify()
    eq2 = BooleanAlgebra().parse(eq2[3:]).simplify()

    return eq1 == eq2


def compare_ref(v1, v2):
    """Compare two vertices' primitive references"""
    if v1["ref"] != v2["ref"]:
        return False

    if not v1["IS_PRIMITIVE"]:
        return True

    props1 = v1["BEL_PROPERTIES"]
    props2 = v2["BEL_PROPERTIES"]
    keys = props1.keys() & props2.keys()
    if "CONFIG.EQN" in keys:
        keys.remove["CONFIG.EQN"]
        if not compare_eqn(props1["CONFIG.EQN"], props2["CONFIG.EQN"]):
            return False
    for prop in keys:
        if props1[prop] != props2[prop]:
            return False
    return True


def is_constant_vertex(v1):
    return v1["ref"] in ["GND", "VCC"]


# It appears that the keys are never used, except inside the get_edge_dict functions.
def create_edge_dict(edge_list1, edge_list2):
    edge_dict = {}
    for e1, e2 in zip_longest(edge_list1, edge_list2, fillvalue={"signal": "port"}):
        if e2["signal"] != "port":
            key = f'{e2["in_pin"]}.{e2["out_pin"]}.{e2["signal"]}'
            edge_dict.setdefault(key, {"e2": [], "e1": []})["e2"].append(e2.source)
        if e1["signal"] != "port":
            key = f'{e1["in_pin"]}.{e1["out_pin"]}.{e1["signal"]}'
            edge_dict.setdefault(key, {"e2": [], "e1": []})["e1"].append(e1.source)
    return edge_dict


def compare_vertex(mapping, g1, v1, g2, v2):
    """Recurisvely compare vertices in two graphs"""
    if is_constant_vertex(v1):
        if compare_ref(v1, v2):
            return mapping
        return False

    if not compare_ref(v1, v2):
        return False

    # Check in edges
    edge_dict = create_edge_dict(v1.in_edges(), v2.in_edges())
    for sources in edge_dict.values():
        src_edges1 = sources["e1"]
        for edge_src2 in sources["e2"]:
            if not src_edges1:  # NO MATCHING EDGES
                return False
            elif len(src_edges1) == 1:  # ONLY ONE MATCHING EDGE
                edge_src1 = src_edges1[0]
                if edge_src1 in mapping:
                    if mapping[edge_src1] != edge_src2:
                        return False
                    src_edges1.remove(edge_src1)
                    continue
                if edge_src2 in mapping.values():
                    return False

                tmp_map = compare_vertex(
                    dict(mapping).update({edge_src1: edge_src2}),
                    g1,
                    g1.vs[edge_src1],
                    g2,
                    g2.vs[edge_src2],
                )
                if not tmp_map:
                    return False

                mapping = tmp_map
                src_edges1.remove(edge_src1)
            else:  # MULTIPLE MATCHING EDGES
                possible_matches = []
                possible_maps = []
                for edge_src1 in src_edges1:
                    if edge_src1 in mapping:
                        if mapping[edge_src1] == edge_src2:
                            possible_matches.append(edge_src1)
                            src_edges1.remove(edge_src1)
                            break
                        continue

                    if edge_src2 in mapping.values():
                        continue

                    tmp_map = compare_vertex(
                        dict(mapping).update({edge_src1: edge_src2}),
                        g1,
                        g1.vs[edge_src1],
                        g2,
                        g2.vs[edge_src2],
                    )

                    if tmp_map:
                        possible_matches.append(edge_src1)
                        possible_maps.append((edge_src1, edge_src2, tmp_map))
                        mapping = possible_maps[0][2]
                        break

                else:
                    if not possible_matches:
                        return False
                    elif len(possible_matches) == 1:
                        mapping = possible_maps[0][2]
                    else:
                        # IF MULTIPLE MATCH, PICK THE FIRST ONE FOR NOW, MAY NEED A "SWAP PORTS" METHOD
                        mapping = possible_maps[0][2]
                        # TODO: If we always pick the first match why keep looking for matches?

    # Check out edges
    edge_dict = create_edge_dict(v1.out_edges(), v2.out_edges())
    for destinations in edge_dict.values():
        dest_edges1 = destinations["e1"]
        for e2_dest in destinations["e2"]:
            if not dest_edges1:  # NO MATCHING EDGES
                return False
            elif len(dest_edges1) == 1:  # ONLY ONE MATCHING EDGE
                e1_dest = dest_edges1[0]
                if e1_dest in mapping:
                    if mapping[e1_dest] != e2_dest:
                        return False
                    dest_edges1.remove(e1_dest)
                    continue

                if e2_dest in mapping.values():
                    return False

                tmp_map = compare_vertex(
                    dict(mapping).update({e1_dest: e2_dest}),
                    g1,
                    g1.vs[e1_dest],
                    g2,
                    g2.vs[e2_dest],
                )
                if not tmp_map:
                    return False

                mapping = tmp_map
                dest_edges1.remove(e1_dest)

            else:  # MULTIPLE MATCHING EDGES
                possible_matches = []
                possible_maps = []
                for e1_dest in dest_edges1:
                    if e1_dest in mapping:
                        if mapping[e1_dest] != e2_dest:
                            continue
                        else:
                            dest_edges1.remove(e1_dest)
                            possible_matches.append(e1_dest)
                            break

                    if e2_dest in mapping.values():
                        continue

                    tmp_map = compare_vertex(
                        dict(mapping).update({e1_dest: e2_dest}),
                        g1,
                        g1.vs[e1_dest],
                        g2,
                        g2.vs[e2_dest],
                    )

                    if tmp_map:
                        dest_edges1.remove(e1_dest)  # this is not done in the in-edge iteration
                        possible_matches.append(e1_dest)
                        possible_maps.append((e1_dest, e2_dest, tmp_map))
                        mapping = possible_maps[0][2]
                        break

                else:
                    if len(possible_matches) == 0:
                        return False
                    elif len(possible_matches) == 1:
                        mapping = possible_maps[0][2]
                    else:
                        # IF MULTIPLE MATCH, PICK THE FIRST ONE FOR NOW, MAY NEED A "SWAP PORTS" METHOD
                        mapping = possible_maps[0][2]

    return mapping

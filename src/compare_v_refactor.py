# Copyright 2020-2022 IPRec Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0

"""
Helper functions importing/exporting iGraphs and comparing vertices

Note:
This file uses the following syntax:

for i in list1:
    for j in list2:
        if x:
            break
    else:
        do something

Familiarize yourself with the syntax here: https://stackoverflow.com/a/1859099
"""

from igraph import Graph
from itertools import zip_longest
import re


######### TCL Generated JSON to iGraph #########
def import_design(design, flat):
    """
    Main function for importing JSON generated by record_core.tcl into
    an iGraph object.
    """
    g = Graph(directed=True)
    cells = design["CELLS"]
    g.add_vertices(len(list(cells.keys())))

    # Import all cells
    for vertex, (i, (c_name, c_info)) in zip(g.vs, enumerate(cells.items())):
        vertex["id"] = i
        vertex["label"] = c_name.split("/")[-1]
        vertex["name"] = c_name
        vertex["parent"] = c_info["PARENT"]
        vertex["IS_PRIMITIVE"] = True if c_info["IS_PRIMITIVE"] else False

        if c_info["IS_PRIMITIVE"] == 1:
            vertex["color"] = "orange"
            vertex["ref"] = c_info["REF_NAME"]
            vertex["BEL_PROPERTIES"] = c_info["BEL_PROPERTIES"]
        else:
            vertex["color"] = "green"
            orig_ref = c_info["ORIG_REF_NAME"]
            vertex["ref"] = orig_ref if orig_ref else c_info["REF_NAME"]
            vertex["CELL_PROPERTIES"] = c_info["CELL_PROPERTIES"]

        if "CELL_NAME" in c_info:
            vertex["CELL_NAME"] = c_info["CELL_NAME"]

        if vertex["ref"] in ["IBUF", "OBUF"]:
            vertex["color"] = "blue"

    if flat:
        return create_edges_flat(g, design["NETS"])

    return create_edges_hier(g, design["NETS"])


def create_edges_flat(g, nets):
    """
    Creates edges from a flat design JSON recorded by record_core.tcl
    """
    vertex_edges = []
    edge_attr = {
        "name": [],
        "parent": [],
        "in_pin": [],
        "out_pin": [],
        "signal": [],
        "ports": [],
    }

    for net, net_info in nets.items():
        parent = net_info["PARENT"]
        driver = net_info["LEAF.0"]["OUTPUTS"]
        if len(driver) != 1:
            continue
        driver = driver[0]
        driver_pin_name = driver.rsplit("/", 1)
        driver_v = g.vs.select(name=driver_pin_name[0])
        if not len(driver_v):
            continue
        driver_idx = driver_v[0].index
        for pin in net_info["LEAF.0"]["INPUTS"]:
            if pin == driver:
                continue
            pin = pin.rsplit("/", 1)
            pin_idx = g.vs.select(name=pin[0])[0].index
            vertex_edges.append((driver_idx, pin_idx))
            edge_attr["name"].append(net)
            edge_attr["parent"].append(parent)
            edge_attr["in_pin"].append(pin[1])
            edge_attr["out_pin"].append(driver_pin_name[1])
            edge_attr["signal"].append("primitive")

    edge_attr["ports"] = [dict() for i in vertex_edges]
    g.add_edges(vertex_edges, edge_attr)
    return g


def create_edges_hier(g, nets):
    """
    Creates edges from a hierarchal design JSON recorded by record_core.tcl
    """
    vertex_edges = []
    edge_attr = {"name": [], "parent": [], "in_pin": [], "out_pin": [], "signal": []}

    for net, net_info in nets.items():
        parent = net_info["PARENT"]
        driver = net_info["DRIVER"]

        if "VCC/P" in driver:
            driver_type = "CONST1"
        elif "GND/G" in driver:
            driver_type = "CONST0"
        else:
            driver_type = "primitive"

        driver_pin_name = driver.rsplit("/", 1)
        driver_v = g.vs.select(name=driver_pin_name[0])
        if not len(driver_v):
            continue

        driver_bool = "LEAF.0"  # default leaf bool
        for pin_dir in ["INPUTS", "OUTPUTS"]:
            for y in net_info["LEAF.1"][pin_dir]:
                if y == driver:
                    driver_bool = "LEAF.1"

        driver_idx = driver_v[0].index
        for leaf_bool in ["LEAF.0", "LEAF.1"]:
            for pin_dir, pins in net_info[leaf_bool].items():
                for pin in pins:
                    if pin == driver:
                        continue
                    pin = pin.rsplit("/", 1)
                    pin_idx = g.vs.select(name=pin[0])
                    if len(pin_idx) != 1:
                        print(f"PIN INDEX ERROR {pin}")
                        continue
                    pin_idx = pin_idx[0].index
                    if driver_bool == "LEAF.1" and leaf_bool == "LEAF.1":
                        edge_type = driver_type
                    else:
                        edge_type = "port"
                    vertex_edges.append((driver_idx, pin_idx))
                    edge_attr["name"].append(net)
                    edge_attr["parent"].append(parent)
                    edge_attr["in_pin"].append(pin[1])
                    edge_attr["out_pin"].append(driver_pin_name[1])
                    edge_attr["signal"].append(edge_type)

    edge_attr["ports"] = [dict() for i in vertex_edges]
    g.add_edges(vertex_edges, edge_attr)
    return g


######### iGraph to Text File #########
def print_graph(graph_obj, f):
    """Print iGraph in readable-text format to a file"""
    print("GRAPH TOP:", file=f)
    for p in graph_obj.attributes():
        print(f"\t{p}: {graph_obj[p]}", file=f)

    for v in graph_obj.vs:
        print(v.index, file=f)
        for p in v.attributes():
            print(f"\t{p}: {v[p]}", file=f)

    for e in graph_obj.es():
        print(e.index, file=f)
        for p in e.attributes():
            print(f"\t{p}: {e[p]}", file=f)
        print(f"\t{e.source} -> {e.target}", file=f)


######### iGraph Comparison Functions #########
def compare_eqn(eq1, eq2):
    eq1_pin_dict = {}
    eq2_pin_dict = {}
    pin_name_list = ["A6", "A5", "A4", "A3", "A2", "A1"]
    eq1_fun = eq1[3:]
    eq2_fun = eq2_fun[3:]

    if "(A6+~A6)*(" in eq1_fun:
        eq1_fun = eq1_fun.replace("(A6+~A6)*(", "")
        eq1_fun = eq1[:-1]
    if "(A6+~A6)*(" in eq2_fun:
        eq2_fun = eq2_fun.replace("(A6+~A6)*(", "")
        eq2_fun = eq2_fun[:-1]

    for pin in pin_name_list:
        eq1_fun = eq1_fun.replace(pin, "PIN")
        eq2_fun = eq2_fun.replace(pin, "PIN")
    if eq1_fun != eq2_fun:
        return False

    for pin in pin_name_list:
        eq1_pin_dict[pin] = [m.start() for m in re.finditer(pin, eq1)]
        eq2_pin_dict[pin] = [m.start() for m in re.finditer(pin, eq2)]
    for pin in eq1_pin_dict:
        for pin2 in eq2_pin_dict:
            if eq1_pin_dict[pin] == eq2_pin_dict[pin2]:
                eq2_pin_dict.pop(pin2, None)
                break
        else:
            return False
    return True


def compare_ref(lh_vertex, rh_vertex):
    """Compare two vertices' primitive references"""
    if lh_vertex["ref"] != rh_vertex["ref"]:
        return False

    if not lh_vertex["IS_PRIMITIVE"]:
        return True

    props1 = lh_vertex["BEL_PROPERTIES"]
    props2 = rh_vertex["BEL_PROPERTIES"]
    keys = props1.keys() & props2.keys()
    if "CONFIG.EQN" in keys:
        keys.remove["CONFIG.EQN"]
        if not compare_eqn(props1["CONFIG.EQN"], props2["CONFIG.EQN"]):
            return False
    for prop in keys:
        if props1[prop] != props2[prop]:
            return False
    return True


def is_constant_vertex(lh_vertex):
    return lh_vertex["ref"] in ["GND", "VCC"]


def create_edge_dict(edge_list1, edge_list2):
    edge_dict = {}
    for e1, e2 in zip_longest(edge_list1, edge_list2, fillvalue={"signal": "port"}):
        if e2["signal"] != "port":
            key = f'{e2["in_pin"]}.{e2["out_pin"]}.{e2["signal"]}'
            edge_dict.setdefault(key, {"e2": [], "e1": []})["e2"].append(e2.source)
        if e1["signal"] != "port":
            key = f'{e1["in_pin"]}.{e1["out_pin"]}.{e1["signal"]}'
            edge_dict.setdefault(key, {"e2": [], "e1": []})["e1"].append(e1.source)
    return edge_dict


def compare_edges(lh_edges, rh_edges, mapping, lh_design, rh_design):
    """
    Compare vertex edges by examinig edge properties and the connected
    vertex.

    lh/rh_edges  ([igraph.Edge]) - Edge list of vertices to compare
    mapping      ({int: int})    - Current estimated matches of
                                 verticies between the two graphs.
                                 mapping[lh_vertex_idx] = rh_vertex_idx
    lh/rh_design (igraph.Graph)  - Graph of design to compare
    """
    edge_dict = create_edge_dict(lh_edges, rh_edges)
    for group in edge_dict.values():
        lh_edges = group["e1"]
        for edge_rh in group["e2"]:
            if not lh_edges:  # NO MATCHING EDGES
                return False
            elif len(lh_edges) == 1:  # ONLY ONE MATCHING EDGE
                edge_lh = lh_edges[0]
                if edge_lh in mapping:
                    if mapping[edge_lh] != edge_rh:
                        return False
                    lh_edges.remove(edge_lh)
                    continue
                if edge_rh in mapping.values():
                    return False

                tmp_map = compare_vertex(
                    dict(mapping).update({edge_lh: edge_rh}),
                    lh_design,
                    lh_design.vs[edge_lh],
                    rh_design,
                    rh_design.vs[edge_rh],
                )
                if not tmp_map:
                    return False

                mapping = tmp_map
                lh_edges.remove(edge_lh)
            else:  # MULTIPLE MATCHING EDGES
                possible_matches = []
                possible_maps = []
                for edge_lh in lh_edges:
                    if edge_lh in mapping:
                        if mapping[edge_lh] != edge_rh:
                            continue
                        possible_matches.append(edge_lh)
                        lh_edges.remove(edge_lh)
                        break

                    if edge_rh in mapping.values():
                        continue

                    tmp_map = compare_vertex(
                        dict(mapping).update({edge_lh: edge_rh}),
                        lh_design,
                        lh_design.vs[edge_lh],
                        rh_design,
                        rh_design.vs[edge_rh],
                    )

                    if tmp_map:
                        lh_edges.remove(edge_lh)
                        possible_matches.append(edge_lh)
                        possible_maps.append((edge_lh, edge_rh, tmp_map))
                        mapping = possible_maps[0][2]
                        break

                else:
                    if not possible_matches:
                        return False
                    elif len(possible_matches) == 1:
                        mapping = possible_maps[0][2]
                    else:
                        # IF MULTIPLE MATCH, PICK THE FIRST ONE FOR NOW, MAY NEED A "SWAP PORTS" METHOD
                        mapping = possible_maps[0][2]
                        # TODO: If we always pick the first match why keep looking for matches?
    return mapping


def compare_vertex(mapping, lh_design, lh_vertex, rh_design, rh_vertex):
    """
    Recurisvely map vertices in two graphs, stemming from lh/rh vertex.

    mapping      ({int: int})    - Current estimated matches of
                                 verticies between the two graphs.
                                 mapping[lh_vertex_idx] = rh_vertex_idx
    lh/rh_design (igraph.Graph)  - Graph of designs to compare.
    lh/rh_vertex (igraph.Vertex) - Verticies to stem comparison from.
    """

    if is_constant_vertex(lh_vertex):
        if compare_ref(lh_vertex, rh_vertex):
            return mapping
        return False

    if not compare_ref(lh_vertex, rh_vertex):
        return False

    # Check in edges
    if not compare_edges(lh_vertex.in_edges(), rh_vertex.in_edges(), mapping, lh_design, rh_design):
        return False
    # Check out edges
    return compare_edges(
        lh_vertex.out_edges(), rh_vertex.out_edges(), mapping, lh_design, rh_design
    )
